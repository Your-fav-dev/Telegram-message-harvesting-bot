"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const types_1 = require("./types");
const interfaces = types_1.default.types.map((type) => {
    return {
        name: type.name,
        description: type.description,
        fields: type.fields.map((fieldType) => {
            return {
                name: fieldType.name,
                description: fieldType.type === "Integer" ? "Integer. " : "" + fieldType.description,
                required: !fieldType.optional,
                type: tmTypeToTs(fieldType.type),
            };
        }),
    };
});
const content = interfaces.map((i) => interfaceToString(i)).join("\n");
fs_1.writeFileSync(__dirname + "/index.d.ts", content);
// tslint:disable-next-line:no-console
console.log("Write successfully " + interfaces.length);
function interfaceToString(iface) {
    return `// ${iface.description}
export interface ${iface.name} {
${iface.fields.map((field) => {
        return "\t" + field.name + (field.required ? "" : "?") + ": " + field.type + "; // " + field.description;
    }).join("\n")}
}
`;
}
exports.interfaceToString = interfaceToString;
function tmTypeToTs(type) {
    switch (type) {
        case "String":
            return "string";
        case "Integer":
            return "number";
        case "Boolean":
            return "boolean";
        default:
            throw new Error("Unknown Telegram type: " + type);
    }
}
exports.tmTypeToTs = tmTypeToTs;
